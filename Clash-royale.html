<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Clash Royale Improved</title>
<style>
  body {
    margin: 0;
    background-color: #7ec0ee;
    font-family: sans-serif;
    overflow: hidden;
    user-select: none;
  }
  canvas {
    display: block;
    margin: auto;
    background-color: #7ec0ee;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="960" height="540"></canvas>
<script>
// ====== Canvas setup ======
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const ARENA_WIDTH = canvas.width;
const ARENA_HEIGHT = canvas.height;
const RIVER_Y = ARENA_HEIGHT/2 - 40;

// ====== Game state ======
const MAX_ELIXIR = 10;
const ELIXIR_REGEN = 0.04;
let playerElixir = MAX_ELIXIR/2;
let enemyElixir = MAX_ELIXIR/2;
let gameOver = false;
let winner = "";

// ====== Assets (placeholder images) ======
const images = {};
const imageSources = {
    "Knight": "https://i.imgur.com/1G8r6kC.png",
    "Archer": "https://i.imgur.com/4p7Bz1h.png",
    "Giant": "https://i.imgur.com/xz5a9fV.png",
    "MiniPekka": "https://i.imgur.com/LzUjszo.png",
    "Wizard": "https://i.imgur.com/BoC3tDF.png",
    "KingTower": "https://i.imgur.com/AK2l5Q5.png",
    "CrownTower": "https://i.imgur.com/akg3frK.png"
};
for(let key in imageSources){
    images[key] = new Image();
    images[key].src = imageSources[key];
}

// ====== Constants ======
const TOWER_WIDTH = 60;
const TOWER_HEIGHT = 100;
const CARD_WIDTH = 60;
const CARD_HEIGHT = 60;
const CARD_SPACING = 10;
const PLAYER_COLOR = "blue";
const ENEMY_COLOR = "red";

// ====== Card stats ======
const typeStats = {
    "Knight": {hp: 300, damage: 50, speed: 1.2, range: 0},
    "Archer": {hp: 150, damage: 25, speed: 1.5, range: 100},
    "Giant": {hp: 600, damage: 70, speed: 0.8, range: 0},
    "MiniPekka": {hp: 250, damage: 90, speed: 1.4, range: 0},
    "Wizard": {hp: 200, damage: 40, speed: 1, range: 80}
};
const cardCost = {
    "Knight":3,
    "Archer":3,
    "Giant":5,
    "MiniPekka":4,
    "Wizard":5
};
const cards = ["Knight","Archer","Giant","MiniPekka","Wizard"];

// ====== Classes ======
class Tower {
    constructor(x, y, isKing=false, owner="enemy") {
        this.x = x;
        this.y = y;
        this.width = isKing?TOWER_WIDTH:50;
        this.height = isKing?TOWER_HEIGHT:80;
        this.hp = isKing?2000:1000;
        this.isKing = isKing;
        this.owner = owner;
        this.image = isKing?images.KingTower:images.CrownTower;
    }
    draw() {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        ctx.fillStyle = "green";
        ctx.fillRect(this.x, this.y-10, this.width*(this.hp/(this.isKing?2000:1000)),5);
    }
}

class Troop {
    constructor(x, y, type, owner="player") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.owner = owner;
        this.hp = typeStats[type].hp;
        this.damage = typeStats[type].damage;
        this.speed = typeStats[type].speed;
        this.range = typeStats[type].range;
        this.width = 40;
        this.height = 40;
        this.target = null;
        this.attackCooldown = 0;
        this.image = images[type];
    }
    draw() {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        ctx.fillStyle = "green";
        ctx.fillRect(this.x, this.y-5, this.width*(this.hp/typeStats[this.type].hp),3);
    }
    move() {
        if(this.target){
            let dx = this.target.x + this.target.width/2 - (this.x + this.width/2);
            let dy = this.target.y + this.target.height/2 - (this.y + this.height/2);
            let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist <= this.range + this.width/2){
                if(this.attackCooldown <=0){
                    this.target.hp -= this.damage;
                    this.attackCooldown = 30;
                }
            } else {
                this.x += dx/dist*this.speed;
                this.y += dy/dist*this.speed;
            }
        } else {
            this.y += this.owner==="player"? -this.speed : this.speed;
        }
        if(this.attackCooldown>0) this.attackCooldown--;
    }
    findTarget(towers, troops){
        let possible = [...towers, ...troops].filter(t=>t.owner!==this.owner && t.hp>0);
        if(possible.length>0){
            possible.sort((a,b)=>Math.abs(this.y-a.y)-Math.abs(this.y-b.y));
            this.target = possible[0];
        }
    }
}

// ====== Game objects ======
let playerTowers = [
    new Tower(ARENA_WIDTH/2 - 150, ARENA_HEIGHT-100,false,"player"),
    new Tower(ARENA_WIDTH/2 + 90, ARENA_HEIGHT-100,false,"player"),
    new Tower(ARENA_WIDTH/2 - TOWER_WIDTH/2, ARENA_HEIGHT-120,true,"player")
];
let enemyTowers = [
    new Tower(ARENA_WIDTH/2 - 150,0,false,"enemy"),
    new Tower(ARENA_WIDTH/2 + 90,0,false,"enemy"),
    new Tower(ARENA_WIDTH/2 - TOWER_WIDTH/2,0,true,"enemy")
];
let playerTroops = [];
let enemyTroops = [];

// ====== Draw arena ======
function drawArena(){
    ctx.fillStyle = "#7ec0ee";
    ctx.fillRect(0,0,ARENA_WIDTH, ARENA_HEIGHT);
    
    ctx.fillStyle = "#1ca3ec";
    ctx.fillRect(0,RIVER_Y,ARENA_WIDTH,80);
    
    // Lanes
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ARENA_WIDTH/2-100,0);
    ctx.lineTo(ARENA_WIDTH/2-100,ARENA_HEIGHT);
    ctx.moveTo(ARENA_WIDTH/2+100,0);
    ctx.lineTo(ARENA_WIDTH/2+100,ARENA_HEIGHT);
    ctx.stroke();
    
    playerTowers.forEach(t=>t.draw());
    enemyTowers.forEach(t=>t.draw());
    
    playerTroops.forEach(t=>t.draw());
    enemyTroops.forEach(t=>t.draw());
    
    // Elixir bars
    ctx.fillStyle = "#00f";
    ctx.fillRect(50, ARENA_HEIGHT-30, playerElixir*20, 20);
    ctx.fillRect(50,10, enemyElixir*20,20);
    
    drawCards();
}

// ====== Cards ======
function drawCards(){
    cards.forEach((c,i)=>{
        let x = 50 + i*(CARD_WIDTH+CARD_SPACING);
        let y = ARENA_HEIGHT - CARD_HEIGHT -10;
        ctx.fillStyle = playerElixir >= cardCost[c]? "#ccc":"#999";
        ctx.fillRect(x,y,CARD_WIDTH,CARD_HEIGHT);
        ctx.drawImage(images[c], x+5, y+5, CARD_WIDTH-10, CARD_HEIGHT-10);
        ctx.fillStyle="#000";
        ctx.font="12px sans-serif";
        ctx.fillText(c, x+5, y+CARD_HEIGHT-5);
    });
}

// ====== Spawn troop ======
function spawnTroop(type, owner){
    if(owner==="player"){
        if(playerElixir>=cardCost[type]){
            playerElixir -= cardCost[type];
            let x = ARENA_WIDTH/2-30 + Math.random()*60;
            let y = ARENA_HEIGHT-100;
            playerTroops.push(new Troop(x,y,type,"player"));
        }
    } else {
        if(enemyElixir>=cardCost[type]){
            enemyElixir -= cardCost[type];
            let x = ARENA_WIDTH/2-30 + Math.random()*60;
            let y = 100;
            enemyTroops.push(new Troop(x,y,type,"enemy"));
        }
    }
}

// ====== Mouse click ======
canvas.addEventListener("click",(e)=>{
    let rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left;
    let my = e.clientY - rect.top;
    cards.forEach((c,i)=>{
        let x = 50 + i*(CARD_WIDTH+CARD_SPACING);
        let y = ARENA_HEIGHT - CARD_HEIGHT -10;
        if(mx>=x && mx<=x+CARD_WIDTH && my>=y && my<=y+CARD_HEIGHT){
            spawnTroop(c,"player");
        }
    });
});

// ====== Enemy AI ======
let enemyTimer = 0;
function enemyAI(){
    enemyTimer++;
    if(enemyTimer>90){
        enemyTimer=0;
        let randomCard = cards[Math.floor(Math.random()*cards.length)];
        spawnTroop(randomCard,"enemy");
    }
}

// ====== Update loop ======
function update(){
    if(gameOver) return;
    
    playerElixir = Math.min(playerElixir + ELIXIR_REGEN, MAX_ELIXIR);
    enemyElixir = Math.min(enemyElixir + ELIXIR_REGEN, MAX_ELIXIR);
    
    playerTroops.forEach(t=>{
        t.findTarget([...enemyTowers], enemyTroops);
        t.move();
    });
    enemyTroops.forEach(t=>{
        t.findTarget([...playerTowers], playerTroops);
        t.move();
    });
    
    playerTroops = playerTroops.filter(t=>t.hp>0);
    enemyTroops = enemyTroops.filter(t=>t.hp>0);
    
    [...playerTowers,...enemyTowers].forEach(t=>{
        if(t.hp<=0 && t.isKing){
            gameOver = true;
            winner = t.owner==="player"?"Enemy":"Player";
        }
    });
    
    enemyAI();
    drawArena();
    
    if(!gameOver){
        requestAnimationFrame(update);
    } else {
        ctx.fillStyle="#000";
        ctx.font="48px sans-serif";
        ctx.fillText(winner + " Wins!", ARENA_WIDTH/2-150, ARENA_HEIGHT/2);
    }
}

update();
</script>
</body>
</html>
