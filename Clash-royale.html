<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Clash Royale</title>
<style>
  body {
    margin: 0;
    background-color: #7ec0ee; /* Sky-blue background */
    overflow: hidden;
    font-family: sans-serif;
    user-select: none;
  }
  canvas {
    display: block;
    margin: auto;
    background-color: #7ec0ee; /* Sky-blue */
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="960" height="540"></canvas>
<script>
// =====================
// ===== Constants =====
// =====================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const FPS = 60;

// Arena
const ARENA_WIDTH = canvas.width;
const ARENA_HEIGHT = canvas.height;
const RIVER_Y = ARENA_HEIGHT / 2 - 40;

// Elixir
const MAX_ELIXIR = 10;
const ELIXIR_REGEN = 0.04; // per frame (~2.4 per second)

// Tower sizes and positions
const TOWER_WIDTH = 40;
const TOWER_HEIGHT = 80;
const KING_TOWER_WIDTH = 60;
const KING_TOWER_HEIGHT = 100;

// Colors
const PLAYER_COLOR = "blue";
const ENEMY_COLOR = "red";
const NEUTRAL_COLOR = "grey";
const CARD_BG = "#eee";
const ELIXIR_COLOR = "#00f";

// =====================
// ===== Game State ====
// =====================
let playerElixir = MAX_ELIXIR / 2;
let enemyElixir = MAX_ELIXIR / 2;

let gameOver = false;
let winner = "";

// =====================
// ===== Classes =======
// =====================

// Basic rectangle Tower
class Tower {
    constructor(x, y, isKing=false, color="red") {
        this.x = x;
        this.y = y;
        this.width = isKing ? KING_TOWER_WIDTH : TOWER_WIDTH;
        this.height = isKing ? KING_TOWER_HEIGHT : TOWER_HEIGHT;
        this.hp = isKing ? 2000 : 1000;
        this.isKing = isKing;
        this.color = color;
        this.shootCooldown = 0;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        // Health bar
        ctx.fillStyle = "green";
        ctx.fillRect(this.x, this.y-10, this.width*(this.hp / (this.isKing?2000:1000)), 5);
    }
}

// Troop class
class Troop {
    constructor(x, y, type, owner="player") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.owner = owner;
        this.width = 20;
        this.height = 20;
        this.speed = typeStats[type].speed;
        this.hp = typeStats[type].hp;
        this.damage = typeStats[type].damage;
        this.range = typeStats[type].range;
        this.target = null;
    }
    draw() {
        ctx.fillStyle = this.owner==="player"?PLAYER_COLOR:ENEMY_COLOR;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        // Health bar
        ctx.fillStyle = "green";
        ctx.fillRect(this.x, this.y-5, this.width*(this.hp/typeStats[this.type].hp),3);
    }
    move() {
        if(this.target){
            // Simple targeting AI
            let dx = this.target.x + this.target.width/2 - (this.x + this.width/2);
            let dy = this.target.y + this.target.height/2 - (this.y + this.height/2);
            let dist = Math.sqrt(dx*dx+dy*dy);
            if(dist <= this.range){
                // Attack
                if(this.attackCooldown<=0){
                    this.target.hp -= this.damage;
                    this.attackCooldown = 30;
                }
            } else {
                this.x += dx/dist*this.speed;
                this.y += dy/dist*this.speed;
            }
        } else {
            // Move forward along lane
            this.y += this.owner==="player"? -this.speed : this.speed;
        }
        if(this.attackCooldown>0) this.attackCooldown--;
    }
    findTarget(towers, troops){
        let possible = [...towers, ...troops].filter(t=>t.owner!==this.owner && t.hp>0);
        if(possible.length>0){
            // Prioritize nearest tower first
            possible.sort((a,b)=>Math.abs(this.y-b.y) - Math.abs(this.y-a.y));
            this.target = possible[0];
        }
    }
}

// Card stats
const typeStats = {
    "Knight": {hp: 300, damage: 50, speed: 1.2, range: 0},
    "Archer": {hp: 150, damage: 25, speed: 1.5, range: 100},
    "Giant": {hp: 600, damage: 70, speed: 0.8, range: 0},
    "MiniPekka": {hp: 250, damage: 90, speed: 1.4, range: 0},
    "Wizard": {hp: 200, damage: 40, speed: 1, range: 80}
};

// Card cost
const cardCost = {
    "Knight":3,
    "Archer":3,
    "Giant":5,
    "MiniPekka":4,
    "Wizard":5
};

// Troops arrays
let playerTroops = [];
let enemyTroops = [];

// Towers
let playerTowers = [
    new Tower(ARENA_WIDTH/2 - 150, ARENA_HEIGHT - TOWER_HEIGHT, false, PLAYER_COLOR),
    new Tower(ARENA_WIDTH/2 + 110, ARENA_HEIGHT - TOWER_HEIGHT, false, PLAYER_COLOR),
    new Tower(ARENA_WIDTH/2 - KING_TOWER_WIDTH/2, ARENA_HEIGHT - KING_TOWER_HEIGHT, true, PLAYER_COLOR)
];

let enemyTowers = [
    new Tower(ARENA_WIDTH/2 - 150, 0, false, ENEMY_COLOR),
    new Tower(ARENA_WIDTH/2 + 110, 0, false, ENEMY_COLOR),
    new Tower(ARENA_WIDTH/2 - KING_TOWER_WIDTH/2, 0, true, ENEMY_COLOR)
];

// =====================
// ===== Draw Arena ====
// =====================
function drawArena(){
    // Clear screen
    ctx.fillStyle = "#7ec0ee";
    ctx.fillRect(0,0,ARENA_WIDTH, ARENA_HEIGHT);
    
    // River
    ctx.fillStyle = "#1ca3ec";
    ctx.fillRect(0,RIVER_Y,ARENA_WIDTH,80);
    
    // Lanes
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ARENA_WIDTH/2 - 100, 0);
    ctx.lineTo(ARENA_WIDTH/2 - 100, ARENA_HEIGHT);
    ctx.moveTo(ARENA_WIDTH/2 + 100, 0);
    ctx.lineTo(ARENA_WIDTH/2 + 100, ARENA_HEIGHT);
    ctx.stroke();
    
    // Draw towers
    playerTowers.forEach(t=>t.draw());
    enemyTowers.forEach(t=>t.draw());
    
    // Draw troops
    playerTroops.forEach(t=>t.draw());
    enemyTroops.forEach(t=>t.draw());
    
    // Draw elixir bars
    ctx.fillStyle = ELIXIR_COLOR;
    ctx.fillRect(50, ARENA_HEIGHT-30, playerElixir*20, 20);
    ctx.fillRect(50, 10, enemyElixir*20, 20);
    
    // Draw card buttons
    drawCardButtons();
}

// =====================
// ===== Cards UI ======
// =====================
const cardWidth = 60;
const cardHeight = 60;
const cardSpacing = 10;
const cards = ["Knight","Archer","Giant","MiniPekka","Wizard"];

function drawCardButtons(){
    cards.forEach((c,i)=>{
        let x = 50 + i*(cardWidth+cardSpacing);
        let y = ARENA_HEIGHT - cardHeight -10;
        ctx.fillStyle = "#ccc";
        ctx.fillRect(x,y,cardWidth,cardHeight);
        // Draw pixel icon (simple colored square)
        ctx.fillStyle = "#666";
        ctx.fillRect(x+10,y+10,cardWidth-20,cardHeight-20);
        // Card name
        ctx.fillStyle = "#000";
        ctx.font = "12px sans-serif";
        ctx.fillText(c, x+5, y+cardHeight-5);
    });
}

// =====================
// ===== Spawn Troop ===
// =====================
function spawnTroop(type, owner){
    if(owner==="player"){
        if(playerElixir>=cardCost[type]){
            playerElixir -= cardCost[type];
            let x = ARENA_WIDTH/2 - 30 + Math.random()*60;
            let y = ARENA_HEIGHT - 100;
            playerTroops.push(new Troop(x,y,type,"player"));
        }
    } else {
        if(enemyElixir>=cardCost[type]){
            enemyElixir -= cardCost[type];
            let x = ARENA_WIDTH/2 -30 + Math.random()*60;
            let y = 100;
            enemyTroops.push(new Troop(x,y,type,"enemy"));
        }
    }
}

// =====================
// ===== Mouse Input ===
// =====================
canvas.addEventListener("click",(e)=>{
    let rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left;
    let my = e.clientY - rect.top;
    
    // Check if clicked on card
    cards.forEach((c,i)=>{
        let x = 50 + i*(cardWidth+cardSpacing);
        let y = ARENA_HEIGHT - cardHeight -10;
        if(mx>=x && mx<=x+cardWidth && my>=y && my<=y+cardHeight){
            spawnTroop(c,"player");
        }
    });
});

// =====================
// ===== AI Logic ======
// =====================
let enemyAItimer = 0;

function enemyAI(){
    enemyAItimer++;
    if(enemyAItimer>90){ // every 1.5 sec
        enemyAItimer=0;
        // Check player's strongest troop near tower
        let pushTroop = playerTroops.filter(t=>t.y>ARENA_HEIGHT/2).sort((a,b)=>b.hp-a.hp)[0];
        if(pushTroop){
            // Defensive: spawn troop to counter
            if(enemyElixir>=3){
                spawnTroop("Knight","enemy");
            }
        } else {
            // Aggressive push
            let randomCard = cards[Math.floor(Math.random()*cards.length)];
            spawnTroop(randomCard,"enemy");
        }
    }
}

// =====================
// ===== Game Loop =====
// =====================
function update(){
    if(gameOver) return;
    
    // Regen elixir
    if(playerElixir<MAX_ELIXIR) playerElixir+=ELIXIR_REGEN;
    if(enemyElixir<MAX_ELIXIR) enemyElixir+=ELIXIR_REGEN;
    
    // Update troops
    playerTroops.forEach(t=>{
        t.findTarget([...enemyTowers], enemyTroops);
        t.move();
    });
    enemyTroops.forEach(t=>{
        t.findTarget([...playerTowers], playerTroops);
        t.move();
    });
    
    // Remove dead troops
    playerTroops = playerTroops.filter(t=>t.hp>0);
    enemyTroops = enemyTroops.filter(t=>t.hp>0);
    
    // Check towers
    [...playerTowers,...enemyTowers].forEach(t=>{
        if(t.hp<=0 && t.isKing){
            gameOver = true;
            winner = t.color===PLAYER_COLOR?"Enemy":"Player";
        }
    });
    
    // AI turn
    enemyAI();
    
    // Draw everything
    drawArena();
    
    if(!gameOver){
        requestAnimationFrame(update);
    } else {
        ctx.fillStyle = "#000";
        ctx.font = "48px sans-serif";
        ctx.fillText(winner + " Wins!", ARENA_WIDTH/2-150, ARENA_HEIGHT/2);
    }
}

// Start game
update();
</script>
</body>
</html>
